blueprint:
  name: SolarFlow Discharge Allow Toggle
  description: |-
    Manages SolarFlow battery discharge permissions by analyzing detailed hourly solar forecasts (from the `wh_period` attribute), household base load, and remaining battery capacity.

    The automation determines how much solar energy can still be generated today and subtracts the estimated household base load for each hour within the solar window.  
    The remaining positive energy balance (the hourly “future surplus”) represents how much solar energy could still be stored in the battery.  
    If this potential surplus exceeds the battery’s remaining capacity, discharge is permitted to make room for the expected incoming energy.  
    Otherwise, discharge is blocked to ensure all solar energy can be stored efficiently.

    How It Works:

    1. Runs every hour and whenever the SoC or Max-SoC values change.
    2. Derives the solar window directly from the forecast hours that have non-zero production values (using `wh_period`).
    3. Calculates per-hour surplus = forecasted Wh − (base load × hour fraction) and sums all remaining solar hours.
    4. Blocks discharge when the battery is set to 100 % max-SoC but has not yet reached it.
    5. Blocks early-morning discharge if SoC is below Min-SoC + buffer and solar production is expected.
    6. Allows discharge only when the forecasted surplus (after baseload subtraction) exceeds the battery’s remaining storable energy.
    7. Updates an input boolean helper that determines whether the SolarFlow may discharge.
    8. Once discharge has been permitted, it remains permitted until the next blocking period (typically the next morning).

    Key Benefits:

    * Prevents wasted solar energy by ensuring capacity is available when new production is expected.
    * Protects the battery by respecting minimum SoC and early-morning buffer levels.
    * Maximizes self-consumption and minimizes grid export.
    * Adapts automatically to each day’s unique solar forecast pattern.
    * Ensures nighttime or early-morning discharge only occurs if there was sufficient solar input earlier in the day.

    Works in conjunction with the **Battery Capacity Calculation** blueprint.

  domain: automation

  input:
    discharge_allowed_helper:
      name: Discharge Allowed Helper
      description: >
        Input boolean that determines whether battery discharge is currently permitted.
        This helper is automatically updated by the blueprint and can also be used
        in other automations to enable or disable discharge behavior.
      selector:
        entity:
          filter:
            domain: input_boolean

    soc_sensor:
      name: State of Charge (SoC) Sensor
      description: >
        Sensor representing the current battery level in percentage.
        Used to evaluate charging and discharging limits.
      selector:
        entity:
          filter:
            domain: sensor

    min_soc_number:
      name: Minimum SoC Number
      description: >
        Numeric entity representing the configured minimum battery SoC (read-only from the battery system).
        Discharge is prevented if the battery level falls below this limit.
      selector:
        entity:
          filter:
            domain: number

    max_soc_number:
      name: Maximum SoC Number
      description: >
        Numeric entity representing the configured maximum battery SoC (read-only from the battery system).
        When set to 100 %, discharge is blocked until the battery reaches full charge.
      selector:
        entity:
          filter:
            domain: number

    energy_production_today_sensor:
      name: Energy Production Today (with wh_period)
      description: >
        Sensor that provides the expected hourly solar production forecast for today.
        It must include an attribute **`wh_period`** containing a mapping of timestamps to
        estimated production (in Wh per hour).  
        The blueprint uses these hourly values, combined with your household base load,
        to calculate the remaining storable solar energy for the rest of the day.
      selector:
        entity:
          filter:
            domain: sensor

    battery_remaining_energy_input:
      name: Battery Remaining Energy Input (Wh)
      description: >
        Input number representing the additional energy capacity (in Wh) that can still
        be stored in the battery.  
        Typically provided by the **Battery Capacity Calculation** blueprint and used
        here to compare against the forecasted solar surplus.
      selector:
        entity:
          filter:
            domain: input_number

    house_baseload_watts:
      name: House Baseload Power (W)
      description: >
        The average household consumption in watts during typical solar hours.
        This value is subtracted from each forecasted solar hour to estimate
        the true “surplus” energy available for charging the battery.
      default: 500
      selector:
        number:
          min: 0
          max: 2000
          unit_of_measurement: W

    solar_end_margin_hours:
      name: Solar Margin (Hours)
      description: >
        Number of hours after the first solar forecast hour to begin evaluating solar production,
        and before the last solar forecast hour to stop considering it.
        This trims the edges of the day to ignore minimal sunrise and sunset output.
      default: 1.5
      selector:
        number:
          min: 0
          max: 6
          step: 0.5
          unit_of_measurement: h

    early_morning_margin_hours:
      name: Early Morning Margin (Hours)
      description: >
        Hours after the first valid solar period during which discharge is only allowed
        if the battery has reached a safe buffer level above Min SoC.
        Prevents unnecessary short charge/discharge cycles early in the day.
      default: 3.0
      selector:
        number:
          min: 0
          max: 12
          step: 0.5
          unit_of_measurement: h

    min_soc_buffer_percent:
      name: Extra SoC Buffer (%)
      description: >
        Additional buffer above the minimum SoC that must be reached before early-morning
        discharge is allowed.  
        For example, with Min SoC = 20 % and Buffer = 10 %, discharge will only be allowed
        once the battery reaches 30 %.
      default: 10
      selector:
        number:
          min: 0
          max: 30
          unit_of_measurement: "%"


variables:
  e_discharge_allowed: !input discharge_allowed_helper
  e_soc_pct: !input soc_sensor
  e_min_soc_pct: !input min_soc_number
  e_max_soc_pct: !input max_soc_number
  e_energy_today: !input energy_production_today_sensor
  e_batt_remaining_wh: !input battery_remaining_energy_input
  v_house_baseload_w: !input house_baseload_watts
  v_solar_margin_h: !input solar_end_margin_hours
  v_early_morning_margin_h: !input early_morning_margin_hours
  v_min_soc_buffer_pct: !input min_soc_buffer_percent

trigger:
  - alias: "Trigger: Every Hour"
    trigger: time_pattern
    hours: "/1"
  - alias: "Trigger: On SoC or Max-SoC Change"
    trigger: state
    entity_id:
      - !input soc_sensor
      - !input max_soc_number

condition: []

action:
  - alias: "Step 1 · Read Current Values"
    variables:
      v_discharge_allowed_now: "{{ is_state(e_discharge_allowed, 'on') }}"
      v_current_soc: "{{ states(e_soc_pct) | float(0) }}"
      v_min_soc: "{{ states(e_min_soc_pct) | float(0) }}"
      v_max_soc: "{{ states(e_max_soc_pct) | float(0) }}"
      v_batt_remaining_wh: "{{ states(e_batt_remaining_wh) | float(0) }}"
      v_wh_period_map: >-
        {% set m = state_attr(e_energy_today, 'wh_period') %}
        {% if m is mapping %}{{ m }}{% else %}{{ dict() }}{% endif %}


  - alias: "Step 2 · Derive Solar Window From wh_period"
    variables:
      v_now_ts: "{{ as_timestamp(now()) | float(0) }}"
      # Find earliest and latest hour blocks with >0 Wh, based on the forecast map we already read.
      v_solar_start_ts: >-
        {% set ns = namespace(earliest=None) %}
        {% for ts, wh in v_wh_period_map | dictsort %}
          {% if (wh | float(0)) > 0 %}
            {% set hs = as_timestamp(ts) | float(0) %}
            {% if ns.earliest is none or hs < ns.earliest %}
              {% set ns.earliest = hs %}
            {% endif %}
          {% endif %}
        {% endfor %}
        {% set start_raw = (ns.earliest if ns.earliest is not none else v_now_ts) %}
        {{ (start_raw + (v_solar_margin_h | float(0)) * 3600) | float(0) }}

      v_solar_end_ts: >-
        {% set ns = namespace(latest=None) %}
        {% for ts, wh in v_wh_period_map | dictsort %}
          {% if (wh | float(0)) > 0 %}
            {% set hs = as_timestamp(ts) | float(0) %}
            {% set he = hs + 3600 %}
            {% if ns.latest is none or he > ns.latest %}
              {% set ns.latest = he %}
            {% endif %}
          {% endif %}
        {% endfor %}
        {% set end_raw = (ns.latest if ns.latest is not none else v_now_ts) %}
        {{ (end_raw - (v_solar_margin_h | float(0)) * 3600) | float(0) }}

      # Human-readable for traces
      v_solar_start_hr: "{{ v_solar_start_ts | timestamp_custom('%Y-%m-%d %H:%M:%S', True) }}"
      v_solar_end_hr:   "{{ v_solar_end_ts   | timestamp_custom('%Y-%m-%d %H:%M:%S', True) }}"

      # Early-morning window relative to the first solar hour (after margin)
      v_is_early_morning: >-
        {{ (v_now_ts >= v_solar_start_ts) and
          (v_now_ts < (v_solar_start_ts + (v_early_morning_margin_h | float(0)) * 3600)) }}



  - alias: "Step 3 · Determine Discharge Block Status"
    variables:
      v_max_soc_blocked: "{{ v_max_soc == 100 and v_current_soc < 100 }}"
      v_early_morning_block: >-
        {{ v_is_early_morning and (v_current_soc < (v_min_soc + v_min_soc_buffer_pct)) }}
      v_discharge_blocked: "{{ v_max_soc_blocked or v_early_morning_block }}"

  - alias: "Step 4 · Compute Future Surplus (Wh) from wh_period minus baseload"
    variables:
      v_future_surplus_wh: >-
        {% set bl_w = v_house_baseload_w | float(0) %}
        {% set solar_start = v_solar_start_ts | float(0) %}
        {% set solar_end = v_solar_end_ts | float(0) %}
        {% set now_ts = v_now_ts | float(0) %}
        {% set m = v_wh_period_map %}
        {% set ns = namespace(total=0.0) %}
        {# Iterate chronologically over the hour buckets #}
        {% for ts, wh in m | dictsort %}
          {% set hs = as_timestamp(ts) if (ts is string) else (as_timestamp(ts|string)) %}
          {% set he = (hs | float(0)) + 3600 %}
          {% set win_start = [hs|float(0), solar_start, now_ts] | max %}
          {% set win_end   = [he|float(0), solar_end] | min %}
          {% set overlap_s = (win_end - win_start) if win_end > win_start else 0 %}
          {% if overlap_s > 0 %}
            {% set frac = (overlap_s / 3600) %}
            {% set rem_wh = (wh | float(0)) * frac %}
            {% set bl_wh  = bl_w * frac %}
            {% set surplus = rem_wh - bl_wh %}
            {% if surplus > 0 %}
              {% set ns.total = ns.total + surplus %}
            {% endif %}
          {% endif %}
        {% endfor %}
        {{ ns.total | float(0) }}

  - alias: "Step 5 · Compute Desired Discharge Permission"
    variables:
      v_expected_surplus_storable_wh: "{{ v_future_surplus_wh | round(0) }}"
      v_batt_capacity_remaining_wh:  "{{ v_batt_remaining_wh | round(0) }}"
      v_expected_grid_overflow_wh: >-
        {% set overflow = (v_future_surplus_wh | float(0)) - (v_batt_remaining_wh | float(0)) %}
        {{ 0 if overflow < 0 else overflow | float(0) }}

      v_discharge_desired_based_on_storage_cap: >-
        {{ (v_future_surplus_wh | float(0)) > (v_batt_remaining_wh | float(0)) }}

      v_discharge_desired: |-
        {% if (v_discharge_blocked | bool(false)) %}
          {% set discharge_allowed_desired = false %}
        {% else %}
          {% if (v_future_surplus_wh | float(0)) > (v_batt_remaining_wh | float(0)) %}
            {% set discharge_allowed_desired = true %}
          {% else %}
            # v_discharge_desired is sticky, if it was set to true after the block, it remains true 
            # hence we only discharge at night/next morning if we had sufficient solar today. If we just had a bit
            # then use it next time. Around midnight we get a new solar estimate, if that does not fit
            # it starts discharging after midnight to make space. Should be fine during the winter
            {% set discharge_allowed_desired = v_discharge_allowed_now %}
          {% endif %}
        {% endif %}
        {{ discharge_allowed_desired }}        

  - alias: "Step 6 · Update Helper if Changed"
    choose:
      - conditions:
          - condition: template
            value_template: "{{ v_discharge_desired != v_discharge_allowed_now }}"
        sequence:
          - action: "input_boolean.turn_{{ 'on' if v_discharge_desired else 'off' }}"
            target:
              entity_id: "{{ e_discharge_allowed }}"

mode: restart
